---
author: David Carslaw
---

# 为Openair图表添加注释 {#sec-annotating-openair}

[openair]{.pkg} 一个经常被问到的问题就是能否为图表添加注释。我们当然可以为[openair]{.pkg}的每一个绘图函数开发用于注释的功能选项，但是那样会非常繁琐而且也很难做到足够灵活。幸运的是[lattice]{.pkg} 和 [latticeExtra]{.pkg} 包中现成的函数可以满足我们各种各样的注释需求。@fig-timePlotAnnotate 通过增加各种可能的注释展示了一个增强版的`timePlot`。这些注释是在基础图上一层一层逐个添加出来的。这一节以 @fig-timePlotAnnotate 为例介绍为 [openair]{.pkg} 图表添加注释的通用方法。后面也会特别介绍极坐标图下的注释，因为会用到不同形式的注释方法。

用作注释的对象包括文字、图形、线段、阴影区等。鉴于大部分 [openair]{.pkg} 图支持多面板同列的功能，我们还需要考虑到如何注释特定的子图。本节下面的示例都适用于 [openair]{.pkg} 中的所有图表，唯一需要考虑的是不同坐标系构图下的区别。

The basis of [openair]{.pkg} annotations is through the use of the [latticeExtra]{.pkg} package, which should already be installed as part of [openair]{.pkg}. In that package there is a function called `layer` that effectively allows annotations to be built up 'layer by layer'.

[openair]{.pkg} 图表注释的基础是 [latticeExtra]{.pkg} 包中的 `layer` 函数，它使我们“一层一层”的叠加注释成为可能。该软件包已经随 [openair]{.pkg} 一起安装。

```{r}
#| label: fig-timePlotAnnotate
#| fig-cap: 添加注释后的 `timePlot`。
#| fig-keep: last
#| echo: false
#| fig-height: 8
#| fig-width: 10
library(openair)
library(lubridate)
poly.na <- function(x1, y1, x2, y2, col = "black", alpha= 0.2) {
  for(i in seq(2, length(x1)))
    if (!any(is.na(y2[c(i - 1, i)])))
      lpolygon(c(x1[i - 1], x1[i], x2[i], x2[i - 1]),
               c(y1[i - 1], y1[i], y2[i], y2[i - 1]),
               col = col, border = NA, alpha = alpha)
}


library(latticeExtra)

## multi-panel time plot
plt <- timePlot(selectByDate(mydata, year = 2003, month = 8),
         pollutant = c("nox", "o3", "pm25", "pm10", "ws"), y.relation = "free")$plot

## [1]
plt <- plt + layer(lpolygon(x = c(ymd("2003-08-07", tz = "GMT"), ymd("2003-08-07", tz = "GMT"),
                                              ymd("2003-08-12", tz = "GMT"), 
                                  ymd("2003-08-12", tz = "GMT")),
                                        y = c(-20, 600, 600, -20), col = "grey", border = NA),
                               under = TRUE, rows = 2)

## [2]
## add text in specific rows
plt <- plt + layer(ltext(x = ymd_hm("2003-08-09 12:00"), y = 50, labels = "!!episode!!",
                                    col = "yellow", font = 2, cex = 1.5), rows = 2)
## [3]
## small rectangle in one panel with semi-transparency
plt <- plt + layer(lpolygon(x = c(ymd("2003-08-21", tz = "GMT"), ymd("2003-08-21", tz = "GMT"),
                                             ymd("2003-08-23", tz = "GMT"), 
                                  ymd("2003-08-23", tz = "GMT")),
                                       y = c(4, 8, 8, 4), col = "blue", border = NA,
                                       alpha = 0.2), rows = 5)
## [4]
## arrows and text
plt <- plt + layer(larrows(ymd_hm("2003-08-01 00:00"), 100, ymd_hm("2003-08-08 14:00"), 100,
                                     code = 3), rows = 1)

plt <- plt + layer(ltext(x = ymd("2003-08-04", tz = "GMT"), y = 200, labels = "some missing data"),
                              rows = 1)
## [5]
## reference line in one panel, with text
plt <- plt + layer(panel.abline(v = ymd("2003-08-25", tz = "GMT"), lty = 5), rows = 4)
plt <- plt + layer(ltext(x = ymd_hm("2003-08-25 08:00"), y = 60,
                                    labels = "reference line", srt = 90), rows = 4)
## [6]
## add a specific point
plt <- plt + layer(lpoints(x[200], y[200], pch = 16, cex = 1.5), rows = 4)

## [7]
## label max ozone
plt <- plt + layer({maxy <- which.max(y);
                               ltext(x[maxy], y[maxy], paste(y[maxy], "ppb"),
                                                           pos = 4)}, rows = 2)

plt <- plt + layer({maxy <- which.max(y); lpoints(x[maxy], y[maxy],
                                                             col = "black", pch = 16)}, rows = 2)

## [8] fill polygon below data; deal with gaps...
plt <- plt + layer({id <- which(x >= ymd("2003-08-11", tz = "GMT") & 
                                  x <= ymd("2003-08-25", tz = "GMT"));
                               poly.na(x[id], y[id], x[id], rep(0, length(id)), col = "darkorange")}, rows = 1)

## [8] fill polygon below data; deal with gaps - bands
plt <- plt + layer(poly.na(x, y, x, rep(0, length(x)), col = "green", alpha = 1),
                              rows = 3)
plt <- plt + layer(poly.na(x, ifelse(y <20, NA, y), x,
                                      rep(20, length(x)), col = "yellow", alpha = 1), rows = 3)
plt <- plt + layer(poly.na(x, ifelse(y <30, NA, y), x, rep(30, length(x)), col = "orange", alpha = 1),
                              rows = 3)
plt <- plt + layer(poly.na(x, ifelse(y <40, NA, y), x, rep(40, length(x)), col = "red", alpha = 1),
                              rows = 3)
plt
```

## 添加文本注释

添加文本注释（或者其它图形注释）的时候需要知道这个文本需要放到图表上的坐标是什么，在不同的图表中这个坐标可能涉及到不同的数据类型。在这个 `timePlot` 示例中，Y轴坐标为数值类型，而X轴坐标需要为日期时间类型（`POSIXct`）。

有多种不同的添加注释的方法，我们这里所采用的方法是通过 `trellis.last.object()`调用上一个图表然后将我们需要注释的内容添加到它上面。这听起来很复杂，但是熟悉示例后会发现这这是一种强大、灵活和直观的方式。在像 @fig-timePlotAnnotate 这样的多面板图中，我们还需要只能将注释添加在哪一行那一列的子图中，否则注释会被尝试添加到所有的面板当中。

首先，我们先绘制待注释的基础图表。

```{r}
#| label: annotatePbase
#| eval: false
## make sure latticeExtra is loaded
library(openair)
library(lubridate)
library(latticeExtra)
timePlot(selectByDate(mydata, year = 2003, month = "aug"),
         pollutant = c("nox", "o3", "pm25", "pm10", "ws"),
         y.relation = "free")
```

然后我们填加文本“some missing data” 到 @fig-timePlotAnnotate 中最上面的面板中。

```{r}
#| label: annotateP1
#| eval: false
trellis.last.object() +
    layer(ltext(x = ymd_hm("2003-08-04 12:00"), y = 200,
                labels = "some missing data"), rows = 1)
```

解释一下这段代码：首先，`trellis.last.object()` 即上一个绘制的图表；然后 `layer` 函数用于添加文本注释的图层。文本本身使用 [lattice]{.pkg} 中的`ltext` 函数添加。建议浏览 `ltext` 函数的帮助文档，了解注释的类型和配置选项。我们这里在X轴为“2003-08-04”、Y轴为200的位置添加文本。`ltext` 函数中的 `pos` 选择用来定义文本相对于坐标点的位置，值可以为1,2,3和4，分别代表位于坐标点的下（默认）、左、上和右边。

## 添加文本和阴影区域

下面我们在第二行的面板（O~3~）中突出显示一段时间并且在上面添加相应的文字。这里使用 `lpolygon` 函数绘制矩形并且指定其位于底层。文本部分我们设置了颜色（黄色）、字体2（粗体）并且适当加大字号（`cex = 1.5`）。注意指定的Y值大于这短时间实际的值域范围是为了确保在何种情况下都能全部覆盖。

`lpolygon` 也可以绘制更复杂的多边形，比如用横向的颜色“带”表示不用的空气质量级别，我们后面会介绍到。

```{r}
#| label: annotateP2
#| eval: false
## add shaded polygon
trellis.last.object() +
    layer(lpolygon(x = c(ymd_hm("2003-08-07 00:00"),
                   ymd_hm("2003-08-07 00:00"), ymd_hm("2003-08-12 00:00"),
                   ymd_hm("2003-08-12 00:00")), y = c(-20, 600, 600, -20),
                   col = "grey", border = NA), under = TRUE, rows = 2)
## add text
trellis.last.object() +
    layer(ltext(x = ymd_hm("2003-08-09 12:00"), y = 50,
                labels = "!!episode!!", col = "yellow",
                font = 2, cex = 1.5), rows = 2)
```

最底部面板中本透明小阴影区域的添加方式如下：

```{r}
#| label: annotateP2a
#| eval: false
## add shaded polygon
plt <- plt +
    layer(lpolygon(x = c(ymd("2003-08-21"), ymd("2003-08-21"),
                   ymd_hm("2003-08-23 00:00"), ymd_hm("2003-08-23 00:00")),
                   y = c(4, 8, 8, 4), col = "blue", border = NA,
                   alpha = 0.2), rows = 5)
```

## 添加箭头

@fig-timePlotAnnotate 中第一个面板中的箭头的添加方式如下。其中 `code = 3` 代表两端都有箭头， `angle` 代表箭柄和箭身的角度。 

```{r}
#| label: annotateP3
#| eval: false
trellis.last.object() +
    layer(larrows(ymd_hm("2003-08-01 00:00"), 100,
                  ymd_hm("2003-08-08 14:00"),
                  100, code = 3, angle = 30), rows = 1)
```

## 添加参考线和文本

下面的代码在第四个面板（PM~10~）中添加了一条垂直的虚线，同时用`ltext`的`srt` 选项将文本逆时针转90度显示。

```{r}
#| label: annotateP4
#| eval: false
trellis.last.object() +
    layer(panel.abline(v = ymd_hm("2003-08-25 00:00"), lty = 5),
          rows = 4)
trellis.last.object() +
    layer(ltext(x = ymd_hm("2003-08-25 08:00"), y = 60,
                labels = "reference line", srt = 90), rows = 4)
```

## 突出显示指定的数据点

到目前为止我们都是通过指定的坐标来决定注释的位置的。如何根据图表上的实际数据自动选定符合条件的点进行注释呢？解锁这一功能会对我们大有帮助。

可以通过面板上点的序号构造出 `x`, `y` 坐标的方式来定位这个点。比如标记第200个PM~10~浓度（不管其具体的日期和浓度值）：


```{r}
#| label: annotateP5
#| eval: false
## add a specific point
trellis.last.object() +
    layer(lpoints(x[200], y[200], pch = 16, cex = 1.5),
          rows = 4)
```

如果我们想要标记最高的 O~3~ 浓度值呢？这需要 通过先索引再在索引位置上做标记和注释的方式实现。这里花括号`{ }`为包含多个命令的代码段。

```{r}
#| label: annotateP6
#| eval: false
## add a point to the max O3 concentration
trellis.last.object() +
    layer({maxy <- which.max(y);
           lpoints(x[maxy], y[maxy], col = "black", pch = 16)},
          rows = 2)

## label max ozone
trellis.last.object() +
    layer({maxy <- which.max(y);
           ltext(x[maxy], y[maxy], paste(y[maxy], "ppb"),
                 pos = 4)}, rows = 2)
```

## 添加填充多边形

在 @fig-timePlotAnnotate 的第一个面板中，我们在中间一段时间的浓度数据曲线下实现了填充效果，这是一种经常会用到的标注方式。但是在根据数值绘制多边形填充之前，先要解决数据缺失情况下的处理问题，否则直接填充会出现问题。下面的函数(`poly.na`)考虑了数据缺失的情况：

```{r}
#| label: polyNA
#| eval: false
poly.na <- function(x1, y1, x2, y2, col = "black", alpha = 0.2) {
  for(i in seq(2, length(x1)))
    if (!any(is.na(y2[c(i - 1, i)])))
      lpolygon(c(x1[i - 1], x1[i], x2[i], x2[i - 1]),
               c(y1[i - 1], y1[i], y2[i], y2[i - 1]),
               col = col, border = NA, alpha = alpha)
}
```

下面我们就可以索引出所有需要标记的数据点的id，然后使用`poly.na`函数进行标记了。这里透明度 alpha 设置为0.2，后面的空气质量等级“色带”示例中可以很容易的改变这个值。

```{r}
#| label: annotateP7
#| eval: false
trellis.last.object() +
    layer({id <- which(x >= ymd_hm("2003-08-11 00:00") &
                       x <= ymd_hm("2003-08-25 00:00"));
           poly.na(x[id], y[id], x[id], rep(0, length(id)),
                   col = "darkorange")}, rows = 1)
```

## 添加空气质量等级色带

将上面的用法拓展便可以视线根据浓度段填色的效果，比如空气质量指数等级。下面的代码绘制了 PM~2.5~ 的浓度色带，按照0--20、20--30、30--40 和 \>40等几个浓度区间分段。

```{r}
#| label: annotateP8
#| eval: false
trellis.last.object() +
    layer(poly.na(x, y, x, rep(0, length(x)),
                  col = "green", alpha = 1), rows = 3)
trellis.last.object() +
    layer(poly.na(x, ifelse(y <20, NA, y), x,
                  rep(20, length(x)), col = "yellow", alpha = 1),
          rows = 3)
trellis.last.object() +
    layer(poly.na(x, ifelse(y <30, NA, y),
                  x, rep(30, length(x)),
                  col = "orange", alpha = 1), rows = 3)
trellis.last.object() +
    layer(poly.na(x, ifelse(y <40, NA, y),
                  x, rep(40, length(x)),
                  col = "red", alpha = 1), rows = 3)
```

## 极坐标图示例

上面所展示的添加文本注释、通过坐标定位注释的位置等功能方法，适用于`timePlot`以外的所以函数，但是那些在使用极坐标系的图中会有些不同，这一节会介绍几个这方面的例子。

首先相对于矩形区域，我们可能会希望再极坐标图里标注一个弧形区域。下面代码构建了一个简单的绘制弧形的函数。其中参数`theta1` 和 `theta2` 指定了角度范围，`lower` 和 `upper` 则指定了极轴上风速的取值区间。`theta3` 和 `theta4`两个可选的参数指定了风速“上限”时的角度范围。 

```{r}
#| label: arcCode
arc <- function(theta1 = 30, theta2 = 60, theta3 = theta1, theta4 = theta2,
                lower = 1, upper = 10){
  ## function to work out coordinates for an arc sector
  if (theta2 < theta1) {
    ang1 <- seq(theta1, 360, length = abs(theta2 - theta1))
    ang2 <- seq(0, theta2, length = abs(theta2 - theta1))
    angles.low <- c(ang1, ang2)

    ## for upper angles
    ang1 <- seq(theta1, 360, length = abs(theta4 - theta3))
    ang2 <- seq(0, theta2, length = abs(theta4 - theta3))
    angles.high <- c(ang1, ang2)

  } else {
    angles.low <- seq(theta1, theta2, length = abs(theta2 - theta1))
    angles.high <- seq(theta3, theta4, length = abs(theta4 - theta3))
  }
  x1 <- lower * sin(pi * angles.low / 180)
  y1 <- lower * cos(pi * angles.low / 180)
  x2 <- rev(upper * sin(pi * angles.high / 180))
  y2 <- rev(upper * cos(pi * angles.high / 180))
  data.frame(x = c(x1, x2), y = c(y1, y2))

}
```

```{r}
#| label: fig-annonatePolar
#| fig-cap: 在极坐标图上添加注释
#| fig-width: 5
#| fig-height: 5
#| out-width: 60%
#| fig-keep: last
#| echo: false
arc <- function(theta1 = 30, theta2 = 60, theta3 =theta1, theta4 = theta2,
                lower = 1, upper = 10){
  ## function to work out coordinates for an arc sector
  if (theta2 < theta1) {
    ang1 <- seq(theta1, 360, length= abs(theta2 - theta1))
    ang2 <- seq(0, theta2, length = abs(theta2 - theta1))
    angles.low <- c(ang1, ang2)

    ## for upper angles
    ang1 <- seq(theta1, 360, length = abs(theta4 - theta3))
    ang2 <- seq(0, theta2, length = abs(theta4 - theta3))
    angles.high <- c(ang1, ang2)

  } else {
    angles.low <- seq(theta1, theta2, length = abs(theta2 - theta1))
    angles.high <- seq(theta3, theta4, length = abs(theta4 - theta3))
  }
  x1 <- lower * sin(pi * angles.low / 180)
  y1 <- lower * cos(pi * angles.low / 180)
  x2 <- rev(upper * sin(pi * angles.high / 180))
  y2 <- rev(upper * cos(pi * angles.high / 180))
  data.frame(x = c(x1, x2), y = c(y1, y2))

}

plt <- polarPlot(mydata, pollutant = "so2", col = "turbo")$plot
plt <- plt + layer(ltext(-12, -12, "A", cex = 2))
plt <- plt + layer(ltext(10, 1, "B", cex = 2, col= "white"))
plt <- plt + layer(lsegments(0, 0, -11.5, -11.5, lty = 5))
plt <- plt +
    layer(lpolygon(x = arc(theta1 = 60, theta2 = 120,
                   lower = 2, upper = 15)$x,
                   y = arc(theta1 = 60, theta2 = 120,
                   lower = 2, upper = 15)$y, lty = 1, lwd = 2))
plt
```

和之前的例子一样，我们在 @fig-annonatePolar SO~2~ 极坐标图中也添加了几种注释。在极坐标系下(0, 0)位于图的中间，到这一点的距离代表风速（或者其它极轴所代表的变量）的大小。这种绘制弧形的方式适用于其它用于做定向性分析的极坐标图。

```{r}
#| label: annotatePolar1
#| eval: false
polarPlot(mydata, pollutant = "so2", col = "turbo")
trellis.last.object() + layer(ltext(-12, -12, "A", cex = 2))
trellis.last.object() + layer(ltext(10, 2, "B", cex = 2, col = "white"))
trellis.last.object() + layer(lsegments(0, 0, -11.5, -11.5, lty = 5))
## add and arc to highlight area of interest
trellis.last.object() +
    layer(lpolygon(x = arc(theta1 = 60, theta2 = 120, lower = 2,
                   upper = 15)$x, y = arc(theta1 = 60,
                                  theta2 = 120, lower = 2,
                                  upper = 15)$y, lty = 1, lwd = 2))
```

## 使用 grid 图形系统 ———— 已交互方式获取注释位置

目前我们都是通过提供在[openair]{.pkg}单面板或多面板图表中精确位置的方式来进行标注的。但是这种方式可能不适用于由几个完全独立图表构成的组合图的，比如 `timeVariation` 函数产出的组合图。在这种情况下我们可以使用 `grid` 包来实现注释。`grid` 是 [lattice]{.pkg} 的底层图形系统，提供更广泛的基数绘图元素，我们这里只给出几个简单的用于注释的例子。

在 `timeVariation` 图中，我们如何在任意位置添加文本呢？比如在月变化图的中间。这时我们可以用`grid`包中的 `grid.locator()` 函数来交互式的获得图中需要添加文本注释的位置信息。这个函数可以使用不同的坐标系————我们这里使用的是图左下角为 (0, 0)，右上角为(1, 1)。

首先，生成需要添加注释的 `timeVariation` 图。

```{r}
#| label: timeVarGrid
#| eval: false
timeVariation(mydata)
```

现在我们用鼠标点选其中月变化图中我们需要添加文本的位置。

```{r}
#| label: gridLocate
#| eval: false
library(grid)
## bring up the interactive location chooser
grid.locator(unit = "npc")
```

这时在R控制台中会返回这个点的坐标，我这里是 x = 0.503 和 y = 0.338。这个坐标就是我们下一步添加合种注释所需要的位置。下面我们使用 `grid.text` 函数在得道的位置上添加文字，设置字体加大（`cex = 2`），加粗（`font = 2`）和蓝色（`col = "blue"`）。

```{r}
#| label: addGridText
#| eval: false
grid.text(x = 0.503, y = 0.338, label = "here!",
          gp = gpar(cex = 2, font = 2, col = "blue"))
```

即使只使用这种简单的方式也可以构建出各种复杂的注释效果，而且适用于*一切* [openair]{.pkg} 图表。`grid`包中也提供了各种函数可以绘制多边形、线段以及其它元素，具体的使用方法与前述示例类似。下面我们添加一个指向周六NO~x~峰值的箭头（位置坐标还是使用 `grid.locator` 获取）。 

```{r}
#| label: addGridArrow
#| eval: false
grid.lines(x = c(0.736, 0.760), y = c(0.560, 0.778),
           arrow = arrow())
grid.text(x = 0.736, y = 0.560, label = "maximum", just = "left")
```

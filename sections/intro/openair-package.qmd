# openair 包 {#openair-package}

在这本书中以下两个包使用非常频繁，建议同时加载。

```{r}
#| message: false
#| warning: false
library(openair)
library(tidyverse)
```

由于 [openair]{.pkg} 包 (和 R 本身) 都会持续更新，所以有必要知道本文档使用 R `r getRversion()` 版本和 [openair]{.pkg} `r packageDescription("openair", field = "Version")`版本制作生成的。

::: callout-note
## 有关函数的帮助信息

在本文档中当代码中的函数名带有超链接时，链接指向此函数的帮助信息。
:::

## 安装步骤和获取代码

[openair]{.pkg} 可以在R环境中通过 [CRAN](https://cran.r-project.org/mirrors.html) (R语言的官方存储库) 获得。我们推荐的做法是先重启R环境然后输入 `install.packages("openair")`。 如果是在 [RStudio](https://rstudio.com/products/rstudio/) (*强烈* 推荐使用)中, 你可以选择右下部的 'packages' 标签页然后点击 'Install'，键入 openair 就可以找到这个软件包了。

[openair]{.pkg} 的全部开发工作都使用 Github 作为版本控制工具。用户可以在 (<https://github.com/davidcarslaw/openair>) 获得 openair 的全部源代码。

Sometimes it might be useful to install the development version of [openair]{.pkg} and you can find instructions [here](https://github.com/davidcarslaw/openair).

在某些情况下，你可能需要安装正在开发中的 [openair]{.pkg} 版本，请访问[这里](https://github.com/davidcarslaw/openair)查询具体方法。

## 对输入数据的要求

[openair]{.pkg} 对于输入数据定义了一些特定的限制要求。**确保输入数据遵循这些限制要求对于使用** [openair]{.pkg} **至关重要**。之所以对输入数据的格式做相对严格的限定，一方面是减少分析过程中出错的可能，另一方面是在后续分析过程中使用更简洁的代码。

-   输入数据应该为 data frame 类型 (或 `tibble`)。

-   **数据中的日期/时间字段应被命名为 `date`** --- 请注意这里为小写字母。任何其它的名字都不被识别。

-   **数据中的风速和风向字段应被分别命名为 `ws` 和 `wd`**， 再次重申这里为小写字母。按照英国气象局的数据格式要求，风向数据通过以正北为起点顺时针的角度来表征，如90度为正东。360同样被认为是正北。

-   当字段为数值类型时，如NO~x~ 的浓度，用户应确保这一整列中没有字符型的数据，经常出现的问题是一些数据集使用 'no data' 来代表缺数。

-   其它的字段名可以是大写或者小写字母，*但是不能以数字作为首字符*。 当参数名中出现空格的时候，R会将其自动替换为句点。使用类似 `PM2.5` 这样的污染物名作为参数名是非常好的做法也完全符合技术要求，但是因为输入起来有点麻烦————更好的做法是直接使用 `pm25` ([openair]{.pkg} 会识别出污染物名并且在生成图表的时候自动转化成 PM~2.5~ 这样的格式)。

## 读取和格式化数据中的日期/时间

对数据中日期/时间的处理是一个复杂的专题，包括时区转换、处理夏令时等等。尽管 [openair]{.pkg} 对日期/时间并没有特别的要求，但是如何正确处理时间是数据分析处理过程中或早或晚需要面对的事情，我们在这里只做简单的介绍。

For a lot of [openair]{.pkg} functions this issue will not be important. While these issues can often be ignored, it is better to be explicit and set the date-time correctly. Two situations where it becomes important is when wanting to show temporal variations in local time and combining data sets that are in different time zones. The former issue can be important (for example) when considering diurnal variations in a pollutant concentration that follows a human activity (such as rush-hour traffic), which follows local time and not GMT/UTC.

[openair]{.pkg} 中的大部分函数会忽略日期/时间带来的隐性问题，分析人员自身最好还是能够正确的理解和设置日期/时间。在两种情况下日期/时间尤其重要，一种是使用本地时而不是格林威治时间/世界时 (GMT/UTC) 进行时间变化分析，例如研究由于人类活动（如交通早高峰）导致的污染物日变化；另一种是跨时区的数据对比分析。

::: callout-important
## 多去了解原始数据!

在把数据导入R之前一定要了解原始数据中日期时间是什么格式，尤其是时区的表征。
:::

在导入数据之前先要去了解原始数据中日期时间的情况。我们人在英国，不用考虑世界时和本地时的区别，但是其它地方就没法这样。However, most air quality and meteorological data around the world tends to be in GMT/UTC or a fixed offset from GMT/UTC i.e. not in local time where hours can be missing or duplicated.

Life is made much easier using the [lubridate]{.pkg} package, which has been developed for working with dates and times. The [lubridate]{.pkg} package has a family of functions that will convert common formats of dates and times into a R-formatted version. These functions are useful when importing data and the date-time is in a character format and needs formatting. Here are some examples:

[lubridate]{.pkg} 包专门用来处理日期和时间，可以大幅简化相关的处理工作。[lubridate]{.pkg} 包内置了一系列函数用来将常用格式的日期和时间转变为R语言可以处理的格式。这些函数可以直接解析字符型的日期和时间。下面是几个例子：

日期时间为“英国”格式 (日/月/年 小时-分钟):

```{r}
library(lubridate) # load package
date_time <- "2/8/2022 11:00"

# format it
dmy_hm(date_time)
```

R显示输出日期时间类型数据时会采用“由大到小”的顺序，如YYYY-MM-DD HH:MM:SS，看到这样的输出可以证明日期时间已经导入成功。

日期时间为“美国”格式，时间精确到秒 (月-日-年):

```{r}
date_time <- "8/2/2022 11:05:12"
mdy_hms(date_time)
```

正如你看到的，在没有特殊指定的情况下日期时间在导入后一律认为是UTC(GMT)时间。如果原始数据所在的时区不是GMT，比我我们假设原始数据的时间有-8小时的固定时差（大概在美国西海岸），在这一步可以对时区加以指定[^openair-package-1]:

[^openair-package-1]: 基于R帮助文档：“可能和你想象的相反(但是和类似“⁠PST8PDT”的命名一致), 时差负值代表时间早于（地理偏东于）UTC，时差正值代表时间晚于（地理偏西于）UTC。”

```{r}
date_time <- "8/2/2022 11:05:12" # time 8 hours behind GMT
mdy_hms(date_time, tz = "Etc/GMT+8")
```

这里指定了该条时间数据和世界时GMT有-8小时的时差。

我们经常需要以本地时间绘制污染物的时间变化曲线。如果数据中的时间是GMT/UTC(或者是GMT/UTC的固定时差)该如何处理呢？

在这种情况下，首先需要了解本地时间以及日光节约时间 (DST) 的表征。本地时区采用奥尔森数据库 (Olson scheme)————使用 `OlsonNames()` 可能得到完整列表。通过 [lubridate]{.pkg} 中的 `with_tz` 函数，我们可以将已经导入的GMT格式的数据显示为本地时间 (BST --- 英国夏令时)：

```{r}
date_time <- "2/8/2022 11:00"

# format it
date_time <- dmy_hm(date_time) # GMT
date_time

# what is the hour?
hour(date_time)

# format in local time
time_local <- with_tz(date_time, tz = "Europe/London")
time_local

# local hour is +1 from GMT
hour(time_local)
```

在上面这个例子中，`date_time` 和 `time_local` 代表的是同一个时间点————我们只是转换了这个时间的显示方式。在实际操作层面通常的做法是，数据集中的 `date` 采用世界时，然后在在使用 [openair]{.pkg} 分析数据的过程中将其转换为本地时，如 `mydata$date -> with_tz(mydata$date, tz = "Europe/London")` 。

另一种情况是使用 [readr]{.pkg} 包的 `read_csv` 这类函数导入数据集时，被识别为日期时间类型的数据会默认赋予 GMT/UTC 时区。后果便是时间的类型和格式被正确导入，但是时间值是错误的。这时需要使用 `force_tz` 函数为已经导入的日期时间数据*强制*赋予时区。如：

```{r}
# a correctly formatted date-time that is in GMT but should be something else
date_time

# force the time zone to be something different
force_tz(date_time, tz = "Etc/GMT+8")
```

最后就是如何合并两个出自不同时区的数据集？@sec-worldmet 将介绍如何获取全球的气象数据（都采用GMT时间），重要的是如何合并来着另一个时区的空气质量数据。其实只要日期时间已经被R正确的识别，接下来要做就是以时间为主键进行合并，R会自动解决时间本身的转换问题。合并两个数据集的例子会在 @sec-link-aq 介绍。

## Brief overview of openair {#brief-intr-open}

This section gives a brief overview of the functions in [openair]{.pkg}. Having read some data into a data frame it is then straightforward to run any function. Almost all functions are run as:



```{r}
#| eval: false
functionName(thedata, options, ...)
```

The usage is best illustrated through a specific example, in this case the `polarPlot` function. The details of the function are shown in @sec-polarPlot and through the help pages (type ?polarPlot). As it can be seen there are numerous options associated with `polarPlot` --- and most other functions and each of these has a default. For example, the default pollutant considered in `polarPlot` is `nox`. If the user has a data frame called `theData` then `polarPlot` could minimally be called by:

```{r}
#| eval: false
polarPlot(theData)
```

which would plot a `nox` polar plot if `nox` was available in the data frame `theData`.

Note that the options do not need to be specified in order nor is it always necessary to write the whole word. For example, it is possible to write:

```{r}
#| eval: false
polarPlot(theData, type = "year", poll = "so2")
```

In this case writing `poll` is sufficient to uniquely identify that the option is `pollutant`.

Also there are many common options available in functions that are not explicitly documented, but are part of lattice graphics. Some common ones are summarised in @tbl-options. The `layout` option allows the user to control the layout of multi-panel plots e.g. `layout = c(4, 1)` would ensure a four-panel plot is 4 columns by 1 row.

```{r}
#| echo: false

tab_dat <- tibble(
  option = c("xlab", "ylab", "main", "pch", "cex", "lty", 
             "lwd", "layout"),
  description = c("x-axis label", "y-axis label", "title of the plot",
                  "plotting symbol used for points",
                  "size of symbol plotted",
                  "line type",
                  "line width",
                  "the plot layout e.g. c(2, 2) "
                  )
)
```

```{r}
#| label: tbl-options
#| tbl-cap: 'Common options used in [openair]{.pkg} plots that can be set by the user but are generally not explicitly documented.'
#| echo: false
knitr::kable(tab_dat, booktabs = TRUE)
```

## The type option

One of the central themes in [openair]{.pkg} is the idea of *conditioning*. Rather than plot $x$ against $y$, considerably more information can usually be gained by considering a third variable, $z$. In this case, $x$ is plotted against $y$ for many different intervals of $z$. This idea can be further extended. For example, a trend of NO~x~ against time can be *conditioned* in many ways: NO~x~ vs. time split by wind sector, day of the week, wind speed, temperature, hour of the day ... and so on. This type of analysis is rarely carried out when analysing air pollution data, in part because it is time consuming to do. However, thanks to the capabilities of R and packages such as [lattice]{.pkg} and [ggplot2]{.pkg}, it becomes easier to work in this way.

In most [openair]{.pkg} functions conditioning is controlled using the `type` option. `type` can be any other variable available in a data frame (numeric, character or factor). A simple example of `type` would be a variable representing a 'before' and 'after' situation, say a variable called `period` i.e. the option `type = "period"` is supplied. In this case a plot or analysis would be separately shown for 'before' and 'after'. When `type` is a numeric variable then the data will be split into four *quantiles* and labelled accordingly. Note however the user can set the quantile intervals to other values using the option `n.levels`. For example, the user could choose to plot a variable by different levels of temperature. If `n.levels = 3` then the data could be split by 'low', 'medium' and 'high' temperatures, and so on. Some variables are treated in a special way. For example if `type = "wd"` then the data are split into 8 wind sectors (N, NE, E, ...) and plots are organised by points of the compass.

There are a series of pre-defined values that `type` can take related to the temporal components of the data as summarised in @tbl-openairType. To use these there *must* be a `date` field so that it can be calculated. These pre-defined values of `type` are shown below are both useful and convenient. Given a data frame containing several years of data it is easy to analyse the data e.g. plot it, by year by supplying the option `type = "year"`. Other useful and straightforward values are "hour" and "month". When `type = "season"` [openair]{.pkg} will split the data by the four seasons (winter = Dec/Jan/Feb etc.). Note for southern hemisphere users that the option `hemisphere = "southern"` can be given. When `type = "daylight"` is used the data are split between nighttime and daylight hours. In this case the user can also supply the options `latitude` and `longitude` for their location (the default is London).

```{r}
#| echo: false

tab_type <- tibble(
  option = c("'year'", "'month'", "'week'", "'monthyear'", "'season'", 
             "'weekday'", "'weekend'", "'daylight'", "'dst'", "'wd'", "'seasonyear'"
             ),
  description = c("splits data by year", 
                  "splits data by month of the year", 
                  "splits data by week of the year",
                  "splits data by year *and* month",
                  "splits data by season. Note in this case the user can also supply a `hemisphere` option that can be either 'northern' (default) or 'southern'",
                  "splits data by day of the week",
                  "splits data by Saturday, Sunday, weekday",
                  " splits data by nighttime/daytime. Note the user must supply a `longitude` and `latitude`",
  "splits data by daylight saving time and non-daylight saving time",
  "if wind direction (`wd`) is available `type = 'wd'` will split the data into 8 sectors: N, NE, E, SE, S, SW, W, NW",
  " will split the data into year-season intervals, keeping the months of a season together. For example, December 2010 is considered as part of winter 2011 (with January and February 2011). This makes it easier to consider contiguous seasons. In contrast, `type = 'season'` will just split  the data into four seasons regardless of the year."
                  )
)
```

```{r}
#| label: tbl-openairType
#| tbl-cap: 'Built-in ways of splitting data in [openair]{.pkg} using the `type` option that is available for most functions.'
#| echo: false
knitr::kable(
  tab_type, booktabs = TRUE
)
```

If a categorical variable is present in a data frame e.g. `site` then that variables can be used directly e.g. `type = "site"`.

### Make your own type

In some cases it is useful to categorise numeric variables according to one's own intervals. One example is air quality bands where concentrations might be described as "good", "fair", "bad". For this situation we can use the `cut` function. In the example below, concentrations of NO~2~ are divided into intervals 0-50, 50-100, 100-150 and \>150 using the `breaks` option. Also shown are user-defined labels. Note there is 1 more break than label. There are a couple of things to note here. First, `include.lowest = TRUE` ensures that the lowest value is included in the lowest break (in this case 0). Second, the maximum value (1000) is set to be more than the maximum value in the data to ensure the final break encompasses all the data.

```{r}
mydata$intervals <- cut(mydata$no2, 
                        breaks = c(0, 50, 100, 150, 1000), 
                        labels = c("Very low", "Low", "High",
                                   "Very High"), 
                        include.lowest = TRUE)

# look at the data
head(mydata)
```

Then it is possible to use the new `intervals` variable in most [openair]{.pkg} functions e.g. `windRose(mydata, type = "intervals")`.

A special case is splitting data by date. In this scenario there might be interest in a 'before-after' situation e.g. due to an intervention. The [openair]{.pkg} function `splitByDate` should make this easy. Here is an example:

```{r}
#| label: splitbydate
splitByDate(
  mydata,
  dates = "1/1/2003",
  labels = c("before", "after"),
  name = "scenario"
)
```

This code adds a new column `scenario` that is labelled `before` and `after` depending on the date. Note that the `dates` input by the user is in British format (dd/mm/YYYY) and that several dates (and labels) can be provided.

## Controlling font size {#font-size}

All [openair]{.pkg} plot functions have an option `fontsize`. Users can easily vary the size of the font for each plot e.g.

```{r}
#| eval: false
polarPlot(mydata, fontsize = 20)
```

The font size will be reset to the default sizes once the plot is complete. Finer control of individual font sizes is currently not easily possible.

## Using colours {#colours}

Many of the functions described require that colour scales are used; particularly for plots showing surfaces. It is only necessary to consider using other colours if the user does not wish to use the default scheme, shown at the top of @fig-colours. The choice of colours does seem to be a vexing issue as well as something that depends on what one is trying to show in the first place. For this reason, the colour schemes used in [openair]{.pkg} are very flexible: if you don't like them, you can change them easily. R itself can handle colours in many sophisticated ways; see for example the `RColorBrewer` package.

Several pre-defined colour schemes are available to make it easy to plot data. In fact, for most situations the default colour schemes should be adequate. The choice of colours can easily be set; either by using one of the pre-defined schemes or through a user-defined scheme. More details can be found in the [openair]{.pkg} `openColours` function. Some defined colours are shown in @fig-colours, together with an example of a user defined scale that provides a smooth transition from red to green.

```{r}
#| label: fig-colours
#| fig-cap: elected pre-defined colour scales in. The top colour scheme is a user-defined one.
#| fig-width: 5
#| fig-height: 7
#| out-width: 70%
library(openair)
## small function for plotting
printCols <- function(col, y) {
    rect((0:200) / 200, y, (1:201) / 200, y + 0.1, col = openColours(col, n = 201),
         border = NA)
    text(0.5, y + 0.15, deparse(substitute(col)))
}

## plot an empty plot
plot(1, xlim = c(0, 1), ylim = c(0, 1.6), type = "n", xlab = "", ylab = "",
     axes = FALSE)
printCols("default", 0)
printCols("increment", 0.2)
printCols("heat", 0.4)
printCols("turbo", 0.6)
printCols("viridis", 0.8)
printCols("inferno", 1.0)
printCols("greyscale", 1.2)
printCols(c("tomato", "white", "forestgreen" ), 1.4)
```

The user-defined scheme is very flexible and the following provides examples of its use. In the examples shown next, the `polarPlot` function is used as a demonstration of their use.

```{r}
#| eval: false
# use default colours - no need to specify
polarPlot(mydata)

# use pre-defined "turbo" colours
polarPlot(mydata, cols = "turbo")

# define own colours going from yellow to green
polarPlot(mydata, cols = c("yellow", "green"))

# define own colours going from red to white to blue
polarPlot(mydata, cols = c("red", "white", "blue"))
```

For more detailed information on using appropriate colours, have a look at the [colorspace](https://cran.r-project.org/web/packages/colorspace/vignettes/colorspace.html) package. [colorspace]{.pkg} provides the definitive, comprehensive approach to using colours effectively. You will need to install the package, `install.packages("colorspace")`. To use the palettes with [openair]{.pkg}, you can for example do:

```{r}
#| fig.width: 4.5
#| fig.height: 4.5
#| out.width: 50%
library(colorspace)
library(openair)
windRose(mydata, cols = qualitative_hcl(4, palette = "Dark 3"))
```

## Automatic text formatting {#quickText}

[openair]{.pkg} tries to automate the process of annotating plots. It can be time-consuming (and tricky) to repetitively type in text to represent μg m^-3^ or PM~10~ (μg m^-3^) etc. in R. For this reason, an attempt is made to automatically detect strings such as `nox` or `NOx` and format them correctly. Where a user needs a y-axis label such as NO~x~ (μg m^-3^) it will only be necessary to type `ylab = "nox (ug/m3)"`. The same is also true for plot titles.

Users can override this option by setting it to FALSE.

## Multiple plots on a page {#sec-multiple-plots-page}

We often get asked how to combine multiple plots on one page. Recent changes to [openair]{.pkg} makes this a bit easier. Note that because [openair]{.pkg} uses [lattice]{.pkg} graphics the base graphics `par` settings will not work.

It is possible to arrange plots based on a column $\times$ row layout. Let's put two plots side by side (2 columns, 1 row). First it is necessary to assign the plots to a variable:

```{r}
#| eval: false
a <- windRose(mydata)
b <- polarPlot(mydata)
```

Now we can plot them using the `split` option:

```{r}
#| eval: false
print(a, split = c(1, 1, 2, 1))
print(b, split = c(2, 1, 2, 1), newpage = FALSE)
```

In the code above for the `split` option, the last two numbers give the overall layout (2, 1) --- 2 columns, 1 row. The first two numbers give the column/row index for that particular plot. The last two numbers remain constant across the series of plots being plotted.

There is one difficulty with plots that already contain sub-plots such as `timeVariation` where it is necessary to identify the particular plot of interest (see the `timeVariation` help for details). However, say we want a polar plot (`b` above) and a diurnal plot:

```{r}
#| eval: false
c <- timeVariation(mydata)
print(b, split = c(1, 1, 2, 1))
print(c, split = c(2, 1, 2, 1), subset = "hour", newpage = FALSE)
```

For more control it is possible to use the `position` argument. `position` is a vector of 4 numbers, c(xmin, ymin, xmax, ymax) that give the lower-left and upper-right corners of a rectangle in which the plot is to be positioned. The coordinate system for this rectangle is \[0--1\] in both the x and y directions.

As an example, consider plotting the first plot in the lower left quadrant and the second plot in the upper right quadrant:

```{r}
#| eval: false
print(a, position = c(0, 0, 0.5, 0.5), more = TRUE)
print(b, position = c(0.5, 0.5, 1, 1))
```

The position argument gives more fine control over the plot location.

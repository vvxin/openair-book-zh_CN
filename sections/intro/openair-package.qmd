---
format:
  html:
    code-annotations: below
    code-copy: false
---

# openair 包 {#openair-package}

在这本书中以下两个包使用非常频繁，建议同时加载。

```{r}
#| message: false
#| warning: false
library(openair)
library(tidyverse)
```

由于 [openair]{.pkg} 包 (和 R 本身) 都会持续更新，所以有必要知道本文档使用 R `r getRversion()` 版本和 [openair]{.pkg} `r packageDescription("openair", field = "Version")`版本制作生成的。

::: callout-note
## 有关函数的帮助信息

在本文档中当代码中的函数名带有超链接时，链接指向此函数的帮助信息。
:::

## 安装步骤和获取代码

[openair]{.pkg} 可以在R环境中通过 [CRAN](https://cran.r-project.org/mirrors.html) (R语言的官方存储库) 获得。我们推荐的做法是先重启R环境然后输入 `install.packages("openair")`。 如果是在 [RStudio](https://rstudio.com/products/rstudio/) (*强烈* 推荐使用)中, 你可以选择右下部的 'packages' 标签页然后点击 'Install'，键入 openair 就可以找到这个软件包了。

[openair]{.pkg} 的全部开发工作都使用 Github 作为版本控制工具。用户可以在 (<https://github.com/davidcarslaw/openair>) 获得 openair 的全部源代码。

Sometimes it might be useful to install the development version of [openair]{.pkg} and you can find instructions [here](https://github.com/davidcarslaw/openair).

在某些情况下，你可能需要安装正在开发中的 [openair]{.pkg} 版本，请访问[这里](https://github.com/davidcarslaw/openair)查询具体方法。

## 对输入数据的要求

[openair]{.pkg} 对于输入数据定义了一些特定的限制要求。**确保输入数据遵循这些限制要求对于使用** [openair]{.pkg} **至关重要**。之所以对输入数据的格式做相对严格的限定，一方面是减少分析过程中出错的可能，另一方面是在后续分析过程中使用更简洁的代码。

-   输入数据应该为 data frame 类型 (或 `tibble`)。

-   **数据中的日期/时间字段应被命名为 `date`** --- 请注意这里为小写字母。任何其它的名字都不被识别。

-   **数据中的风速和风向字段应被分别命名为 `ws` 和 `wd`**， 再次重申这里为小写字母。按照英国气象局的数据格式要求，风向数据通过以正北为起点顺时针的角度来表征，如90度为正东。360同样被认为是正北。

-   当字段为数值类型时，如NO~x~ 的浓度，用户应确保这一整列中没有字符型的数据，经常出现的问题是一些数据集使用 'no data' 来代表缺数。

-   其它的字段名可以是大写或者小写字母，*但是不能以数字作为首字符*。 当参数名中出现空格的时候，R会将其自动替换为句点。使用类似 `PM2.5` 这样的污染物名作为参数名是非常好的做法也完全符合技术要求，但是因为输入起来有点麻烦————更好的做法是直接使用 `pm25` ([openair]{.pkg} 会识别出污染物名并且在生成图表的时候自动转化成 PM~2.5~ 这样的格式)。

## 读取和格式化数据中的日期/时间

对数据中日期/时间的处理是一个复杂的专题，包括时区转换、处理夏令时等等。尽管 [openair]{.pkg} 对日期/时间并没有特别的要求，但是如何正确处理时间是数据分析处理过程中或早或晚需要面对的事情，我们在这里只做简单的介绍。

For a lot of [openair]{.pkg} functions this issue will not be important. While these issues can often be ignored, it is better to be explicit and set the date-time correctly. Two situations where it becomes important is when wanting to show temporal variations in local time and combining data sets that are in different time zones. The former issue can be important (for example) when considering diurnal variations in a pollutant concentration that follows a human activity (such as rush-hour traffic), which follows local time and not GMT/UTC.

[openair]{.pkg} 中的大部分函数会忽略日期/时间带来的隐性问题，分析人员自身最好还是能够正确的理解和设置日期/时间。在两种情况下日期/时间尤其重要，一种是使用本地时而不是格林威治时间/世界时 (GMT/UTC) 进行时间变化分析，例如研究由于人类活动（如交通早高峰）导致的污染物日变化；另一种是跨时区的数据对比分析。

::: callout-important
## 多去了解原始数据!

在把数据导入R之前一定要了解原始数据中日期时间是什么格式，尤其是时区的表征。
:::

在导入数据之前先要去了解原始数据中日期时间的情况。我们人在英国，不用考虑世界时和本地时的区别，但是其它地方就没法这样。However, most air quality and meteorological data around the world tends to be in GMT/UTC or a fixed offset from GMT/UTC i.e. not in local time where hours can be missing or duplicated.

Life is made much easier using the [lubridate]{.pkg} package, which has been developed for working with dates and times. The [lubridate]{.pkg} package has a family of functions that will convert common formats of dates and times into a R-formatted version. These functions are useful when importing data and the date-time is in a character format and needs formatting. Here are some examples:

[lubridate]{.pkg} 包专门用来处理日期和时间，可以大幅简化相关的处理工作。[lubridate]{.pkg} 包内置了一系列函数用来将常用格式的日期和时间转变为R语言可以处理的格式。这些函数可以直接解析字符型的日期和时间。下面是几个例子：

日期时间为“英国”格式 (日/月/年 小时-分钟):

```{r}
library(lubridate) # load package
date_time <- "2/8/2022 11:00"

# format it
dmy_hm(date_time)
```

R显示输出日期时间类型数据时会采用“由大到小”的顺序，如YYYY-MM-DD HH:MM:SS，看到这样的输出可以证明日期时间已经导入成功。

日期时间为“美国”格式，时间精确到秒 (月-日-年):

```{r}
date_time <- "8/2/2022 11:05:12"
mdy_hms(date_time)
```

正如你看到的，在没有特殊指定的情况下日期时间在导入后一律认为是UTC(GMT)时间。如果原始数据所在的时区不是GMT，比我我们假设原始数据的时间有-8小时的固定时差（大概在美国西海岸），在这一步可以对时区加以指定[^openair-package-1]:

[^openair-package-1]: 基于R帮助文档：“可能和你想象的相反(但是和类似“⁠PST8PDT”的命名一致), 时差负值代表时间早于（地理偏东于）UTC，时差正值代表时间晚于（地理偏西于）UTC。”

```{r}
date_time <- "8/2/2022 11:05:12" # time 8 hours behind GMT
mdy_hms(date_time, tz = "Etc/GMT+8")
```

这里指定了该条时间数据和世界时GMT有-8小时的时差。

我们经常需要以本地时间绘制污染物的时间变化曲线。如果数据中的时间是GMT/UTC(或者是GMT/UTC的固定时差)该如何处理呢？

在这种情况下，首先需要了解本地时间以及日光节约时间 (DST) 的表征。本地时区采用奥尔森数据库 (Olson scheme)————使用 `OlsonNames()` 可能得到完整列表。通过 [lubridate]{.pkg} 中的 `with_tz` 函数，我们可以将已经导入的GMT格式的数据显示为本地时间 (BST --- 英国夏令时)：

```{r}
date_time <- "2/8/2022 11:00"

# format it
date_time <- dmy_hm(date_time) # GMT
date_time

# what is the hour?
hour(date_time)

# format in local time
time_local <- with_tz(date_time, tz = "Europe/London")
time_local

# local hour is +1 from GMT
hour(time_local)
```

在上面这个例子中，`date_time` 和 `time_local` 代表的是同一个时间点————我们只是转换了这个时间的显示方式。在实际操作层面通常的做法是，数据集中的 `date` 采用世界时，然后在在使用 [openair]{.pkg} 分析数据的过程中将其转换为本地时，如 `mydata$date -> with_tz(mydata$date, tz = "Europe/London")` 。

另一种情况是使用 [readr]{.pkg} 包的 `read_csv` 这类函数导入数据集时，被识别为日期时间类型的数据会默认赋予 GMT/UTC 时区。后果便是时间的类型和格式被正确导入，但是时间值是错误的。这时需要使用 `force_tz` 函数为已经导入的日期时间数据*强制*赋予时区。如：

```{r}
# a correctly formatted date-time that is in GMT but should be something else
date_time

# force the time zone to be something different
force_tz(date_time, tz = "Etc/GMT+8")
```

最后就是如何合并两个出自不同时区的数据集？@sec-worldmet 将介绍如何获取全球的气象数据（都采用GMT时间），重要的是如何合并来着另一个时区的空气质量数据。其实只要日期时间已经被R正确的识别，接下来要做就是以时间为主键进行合并，R会自动解决时间本身的转换问题。合并两个数据集的例子会在 @sec-link-aq 介绍。

## Brief overview of openair {#brief-intr-open}

本小节将概述 [openair]{.pkg} 中函数的使用方法。成功导入数据框后就可以对其执行任意的函数了，几乎所有的函数都以如下方式运行：

```{r}
#| eval: false
functionName(thedata, options, ...)
```

我们接下来用 `polarPlot` 这样一个特定的函数作为例子进一步解释大部分函数的使用方法。关于这个函数的详细资料会在 @sec-polarPlot 介绍，也可以查看其帮助页 (输入 ?polarPlot)。 包括 `polarPlot` 在内的大部分函数都有很多参数选项，但是这些选项也都预先设置了缺省值。比如`polarPlot` 中污染物选项的缺省值是 `nox`。如果用户已经导入了明白 `theData` 的数据框，那么极简的执行 `polarPlot` 的方式是：

```{r}
#| eval: false
polarPlot(theData)
```

这时候 `theData` 数据框中 的 `nox` （如果有的话）会被缺省的用来绘制一张 `nox` 的 polar plot。

函数的输入参数不需要特定的顺序，参数名在不引起歧义的情况下也不需要输入完整。下面就是一条合法的命令代码：

```{r}
#| eval: false
polarPlot(theData, type = "year", poll = "so2")
```

在上例中 `poll` 已经可以足够代表 `pollutant` 这个参数。

另外你会发现函数中有很多可用的参数却并没有在文档中体现，因为这些参数是从lattice绘图系统中继承下来的。其中常用的几个汇总在 @tbl-options 中。 比如 `layout` 输入参数允许用户控制 multi-panel plots 的具体布局。比如 `layout = c(4, 1)` 参数将使用4列1行的布局来输出。

```{r}
#| echo: false

tab_dat <- tibble(
  option = c("xlab", "ylab", "main", "pch", "cex", "lty", 
             "lwd", "layout"),
  description = c("x-axis label", "y-axis label", "title of the plot",
                  "plotting symbol used for points",
                  "size of symbol plotted",
                  "line type",
                  "line width",
                  "the plot layout e.g. c(2, 2) "
  )
)
```

```{r}
#| label: tbl-options
#| tbl-cap: 'Common options used in [openair]{.pkg} plots that can be set by the user but are generally not explicitly documented.'
#| echo: false
knitr::kable(tab_dat, booktabs = TRUE)
```

## type 选项

[openair]{.pkg} 的一个核心主题是 *条件* 思维。 在分析 $x$ 和 $y$ 之间关系的时候，引入第三个参数 $z$ 通常会让我们得到更多的信息，也就是看在 $z$ 的不同取值区间下 $x$ 和 $y$ 之前关系的区别。比如，我们可以为 NO~x~ 随时间的变化趋势增加多种不同的 *条件* ：不同风向条件下的 NO~x~ 随时间变化，一周中不同日的 NO~x~ 随时间变化，不同风速条件下的 NO~x~ 随时间变化，不同气温条件下的 NO~x~ 随时间变化，一天中不同小时的 NO~x~ 随时间变化……等等。这类分析手段比较少的用于空气污染数据分析，一定程度上是由于数据处理起来很麻烦。现在在R语言环境中借助 [lattice]{.pkg} 和 [ggplot2]{.pkg} 包，条件分析变得简单方便多了。

[openair]{.pkg} 中函数通过 `type` 选项来控制条件分析。 `type` 可以是数据框中任何一个可用的参数 (numeric, character or factor)。一个简单的通过 `type` 分类的例子是用一个叫做 `period` 的参数来代表 'before' 和 'after' 两种情景, 然后输入 `type = "period"` 这个参数。 这时图表会将代表 'before' 和 'after' 两个情景的数据分开进行绘制和和对比。当 `type` 是数值型的参数时，数据会将这个参数的4个分位数作为条件进行分割然后分别绘图，相应的图例也会自动生成。用户可以通过 `n.levels` 参数自定义分割的区间。如：通过 `n.levels = 3` 将气温分为 'low'、'medium' 和 'high'三个条件区间。有个别的参数会特殊处理，比如 `type = "wd"` 将会把风向自动分成8个区间 (N, NE, E, ...)， 生成的图表也会按照方向方位来进行排版。

@tbl-openairType 中列出 两关于时间区间的内置 `type` 选项，这可以进一步方便按条件分析的相关操作。注意*只有*当数据框中包含 `date` 参数才可以进行时间区间的计算。例如当数据集包含多年的长时间序列时，只需要加入 `type = "year"` 参数就可以轻松的按年来分别绘图。按 "hour" 和按 "month" 也比较常用。 当选择 `type = "daylight"` 时，[openair]{.pkg} 会自动将数据分为四个季节(冬天为十二月/一月/二月，以此类推)。南半球的用户需要同时使用 `hemisphere = "southern"` 参数。`type = "daylight"` 参数将数据分为白天和夜间，这时用户需要通过 `latitude` and `longitude` 参数提供位置信息（默认位置为伦敦）。

```{r}
#| echo: false

tab_type <- tibble(
  option = c("'year'", "'month'", "'week'", "'monthyear'", "'season'", 
             "'weekday'", "'weekend'", "'daylight'", "'dst'", "'wd'", "'seasonyear'"
  ),
  description = c("splits data by year", 
                  "splits data by month of the year", 
                  "splits data by week of the year",
                  "splits data by year *and* month",
                  "splits data by season. Note in this case the user can also supply a `hemisphere` option that can be either 'northern' (default) or 'southern'",
                  "splits data by day of the week",
                  "splits data by Saturday, Sunday, weekday",
                  " splits data by nighttime/daytime. Note the user must supply a `longitude` and `latitude`",
                  "splits data by daylight saving time and non-daylight saving time",
                  "if wind direction (`wd`) is available `type = 'wd'` will split the data into 8 sectors: N, NE, E, SE, S, SW, W, NW",
                  " will split the data into year-season intervals, keeping the months of a season together. For example, December 2010 is considered as part of winter 2011 (with January and February 2011). This makes it easier to consider contiguous seasons. In contrast, `type = 'season'` will just split  the data into four seasons regardless of the year."
  )
)
```

```{r}
#| label: tbl-openairType
#| tbl-cap: 'Built-in ways of splitting data in [openair]{.pkg} using the `type` option that is available for most functions.'
#| echo: false
knitr::kable(
  tab_type, booktabs = TRUE
)
```

数据框中可以作为分类的参数，如站点名`site` 等，都可以直接用 `type = "site"` 的方式进行条件分析。

### 自定义 type

有时用户希望将数值型的参数按照自己希望的区间进行分段。一个典型的场景是为污染物浓度设置区间来将空气质量归类为 "good", "fair", "bad"等。在这种情况下我们需要用到 `cut` 函数。下面的例子用 `breaks` 参数将 NO~2~ 的浓度分为0-50、50、100、100-150和\>150这几个区间，同时为每个区间指定了标签，注意提供的分割点会比标签名多一个。还有几个注意事项，首先 `include.lowest = TRUE` 确保最小的值被包含到最小的浓度区间（这个例子中的0）；第二，设置一个比最高的浓度值还要大的最大分段值（这个例子中的1000）以确保全部数据被纳入分段。

```{r}
mydata$intervals <- cut(mydata$no2, 
                        breaks = c(0, 50, 100, 150, 1000), 
                        labels = c("Very low", "Low", "High",
                                   "Very High"), 
                        include.lowest = TRUE)

# look at the data
head(mydata)
```

接下来就可以在 [openair]{.pkg} 的大部分函数使用用新生成的 `intervals` 参数作为分段条件了，如：`windRose(mydata, type = "intervals")`。

A special case is splitting data by date. In this scenario there might be interest in a 'before-after' situation e.g. due to an intervention. The [openair]{.pkg} function `splitByDate` should make this easy. Here is an example:

对时间进行分段和对数值进行有所不同，就像前文提到的空气改善措施“前-后”对比分析的场景。我们可以通过 [openair]{.pkg} 的`splitByDate` 函数轻松实现：

```{r}
#| label: splitbydate
splitByDate(
  mydata,
  dates = "1/1/2003",
  labels = c("before", "after"),
  name = "scenario"
)
```

这段代码为数据增加了一列新的 `scenario` 场景列，并根据时间赋值为 `before` 和 `after`。 Note that the `dates` input by the user is in British format (dd/mm/YYYY) and that several dates (and labels) can be provided.

## 字体大小 {#font-size}

所有的 [openair]{.pkg} 绘图函数都可以通过 `fontsize` 选项设置图表中的字号。例如：

```{r}
#| eval: false
polarPlot(mydata, fontsize = 20)
```

在制图执行完成后字号会重置到缺省状态。对特定文字的字号微调在目前还不太容易实现。

## 颜色选项 {#colours}

我们提到的大部分函数都需要用不同的颜色来代表不同的类别或者程度，对需要在平面中展示高低数值的图来说颜色更加重要。如果 @fig-colours 中缺省的配色方案不能满足需求，那么就要特别的考虑颜色选项的问题了。选择一套合适的颜色并不简单，这很大程度上也取决去你在一开始打算如何表达这些数据。所以 [openair]{.pkg} 提供了丰富的颜色方案和灵活的配置方式。更多的例子可以查看 `RColorBrewer` 包。

为了方便使用，软件中已经内置了几种配色方案。其实，在大多数情况下缺省的配色应该就可以满足需要了。调整配色也很简单，要么选择使用一种内置配色，要么使用用户自定义配色。详细信息请查看 [openair]{.pkg} 等 `openColours` 函数。@fig-colours 展示了部分内置的配色方案以及一个从红色到绿色渐变的用户自定义配色。

```{r}
#| label: fig-colours
#| fig-cap: elected pre-defined colour scales in. The top colour scheme is a user-defined one.
#| fig-width: 5
#| fig-height: 7
#| out-width: 70%
library(openair)
## small function for plotting
printCols <- function(col, y) {
  rect((0:200) / 200, y, (1:201) / 200, y + 0.1, col = openColours(col, n = 201),
       border = NA)
  text(0.5, y + 0.15, deparse(substitute(col)))
}

## plot an empty plot
plot(1, xlim = c(0, 1), ylim = c(0, 1.6), type = "n", xlab = "", ylab = "",
     axes = FALSE)
printCols("default", 0)
printCols("increment", 0.2)
printCols("heat", 0.4)
printCols("turbo", 0.6)
printCols("viridis", 0.8)
printCols("inferno", 1.0)
printCols("greyscale", 1.2)
printCols(c("tomato", "white", "forestgreen" ), 1.4)
```

下面的几个例子展示了如何在 `polarPlot` 函数中应用用户自定义配色。

```{r}
#| eval: false
# use default colours - no need to specify
polarPlot(mydata)

# use pre-defined "turbo" colours
polarPlot(mydata, cols = "turbo")

# define own colours going from yellow to green
polarPlot(mydata, cols = c("yellow", "green"))

# define own colours going from red to white to blue
polarPlot(mydata, cols = c("red", "white", "blue"))
```

如果希望了解更多关于在科技制图中如果正确运用颜色的知识，不妨查看一下 [colorspace](https://cran.r-project.org/web/packages/colorspace/vignettes/colorspace.html) 包。[colorspace]{.pkg} 提供了这方面权威和全面的方法论和工具集。你需要安装这个软件包 `install.packages("colorspace")`，然后按照下面的示例在 [openair]{.pkg} 中引用相关的调色板：

```{r}
#| label: fig-colorspace
#| fig-cap: A demonstration of the [colorspace]{.pkg} package in use with [openair]{.pkg}.
#| fig.width: 4.5
#| fig.height: 4.5
#| out.width: 50%
#| fig-align: center
library(colorspace)
library(openair)
windRose(mydata, cols = qualitative_hcl(4, palette = "Dark 3"))
```

## Automatic text formatting {#quickText}

[openair]{.pkg} 会尝试自动完成图表中的文字标注。实现类似 μg m^-3^ 或 PM~10~ (μg m^-3^) 这样的有特殊格式的文本在R中并不容易，而且一次一次的输入也很麻烦。因此，我们让 [openair]{.pkg} 可以自动识别 `nox` 或 `NOx` 这种字符串然后为它们匹配正确的格式。如果用户将 NO~x~ (μg m^-3^) 作为Y轴的标题，只需要键入 `ylab = "nox (ug/m3)"` 就可以了。同样的功能也适用于图表的大标题。

如果用户需要避免这样的自动格式，可以将这个功能设置为 FALSE。

## 一页多图 {#sec-multiple-plots-page}

我们经常需要在一个页面视图中合并几张图表。[openair]{.pkg} 的新近的更新简化了这项功能的实现。注意这里由于 [openair]{.pkg} 使用 [lattice]{.pkg} 图形系统作制图，所以R基本绘图系统中的 `par` 设置无法使用。

我们可以将几张图表安装列 $\times$ 行的方式进行排版，那么双图横行同列就是2列、1行。首先将两幅图分别赋值给一个变量：

```{r}
#| eval: false
a <- windRose(mydata)
b <- polarPlot(mydata)
```

然后我们用 `split` 选项来组织输出：

```{r}
#| eval: false
print(a, split = c(1, 1, 2, 1))
print(b, split = c(2, 1, 2, 1), newpage = FALSE)
```

上面代码中的 `split` 选项中，后两个数字代表总体的行列布局layout (2, 1)即2列1行，前两个数字代表所在的那一副图所在的行列坐标。所以在一组多图中后两个数字应该是保持不变的。

当一副图已经是又几个子图组成的时候，如 `timeVariation` ，在进行多图同列的时候需要制定是其中的哪一个子图参与同列（详见 `timeVariation` 的帮助文档）。假设我们需要一个polar plot（上面的 `b` ）和一个日变化图放到一起，那么：

```{r}
#| eval: false
c <- timeVariation(mydata)
print(b, split = c(1, 1, 2, 1))
print(c, split = c(2, 1, 2, 1), subset = "hour", newpage = FALSE)
```

 还可以使用 `position` 参数更精确的控制每一副图的具体位置。`position` 由一组4个数的向量组成，c(xmin, ymin, xmax, ymax)通过定义左下角和右上角两个坐标来确定图表放置的矩形区域。整体绘图区域的x和y轴都是\[0--1\]的取值区间。

如果想要将一副图放在左下象限的位置，另一副图放在右上象限的位置，那么代码如下：

```{r}
#| eval: false
print(a, position = c(0, 0, 0.5, 0.5), more = TRUE)
print(b, position = c(0.5, 0.5, 1, 1))
```

The position argument gives more fine control over the plot location.

## Saving plots and data

While you'll likely be using [openair]{.pkg} in an environment like [RStudio](https://rstudio.com/products/rstudio/), you'll likely want to get the outputs of your analysis *outside* of RStudio to put into reports, papers, or other deliverables.

For data, this is relatively straightforward. The `write.csv()` function will write out a dataframe to a local file path. The only arguments it really needs is `x` (the dataframe to save) and `file` (the file path to save it to). For example, the below code chunk will load annual statistics for the Marylebone Road monitoring site, and save them to the path `"my1_annual-stats_2022.csv"`. Always try to give files evocative names so you'll know what's in them in future - `"my1_annual-stats_2022.csv"` is better than `"data.csv"`.

```{r}
#| label: demosavecsv
#| eval: false
library(openair)

marylebone <-
  importUKAQ(site = "my1",
             year = 2022,
             source = "aurn",
             data_type = "annual", 
             to_narrow = TRUE)

write.csv(x = marylebone, file = "my1_annual-stats_2022.csv")

```

Plots are slightly more complicated. If you do use RStudio, the simplest way to save an openair plot is to use the plots pane, visualised in @fig-rstudiosave. This menu will allow you to copy your plot to the clipboard, or save it as an image or PDF.

![A screenshot of the 'Export' menu of the RStudio plots pane.](../../assets/media/rstudio-saving.png){#fig-rstudiosave}

This may be useful in some scenarios, but using the RStudio GUI is not very reproducible. For sake of example, say you make a new set of plots every week for a weekly report. You may not want to have to repeatedly go into the plots pane, click 'export', set the correct dimensions, and so on every time a new plot needs to be saved. It would be preferable if your script created the plots *and* saved them! 

To write a script to save a plot, use the following approach:

1. **Create your [openair]{.pkg} plot**, making sure to assign it (`<-`) to a variable name.

2. **Open a graphics device**, such as `png()`, `jpeg()`, `png()`, and so on. This is the stage where you'll set parameters like the width, height, and resolution. You'll also need to define a path, much like when you save data. As before, give it an evocative name - `"polarplot_marylebone_nox.png"` is a lot more descriptive than `"myplot.png"`. You'll note that a file is created in your working directory, but it will be blank for the moment.

3. **Print the plot**. In [openair]{.pkg}, this can typically achieved by simply printing the whole [openair]{.pkg} object. Note that the plot will not appear in your plots pane in RStudio - it is being printed to the file you've created.

4. **Close the graphics device**. This is simply achieved using `dev.off()` regardless of your chosen device, and tells R to close the connection to the device. The image of the plot will now appear in the file you created in step 2.

::: {.column-margin}
Many R users will be familiar with `ggplot2::ggsave()` for saving plots. [openair]{.pkg} predates [ggplot2]{.pkg}, so this function will not work with [openair]{.pkg} plots.
:::

```{r}
#| label: demo-saveplot
#| eval: false
library(openair)

# STEP 1: Make a polarPlot
polar <- polarPlot(mydata, "nox")

# STEP 2: Open a graphics device
png(filename = "polarplot_marylebone_nox.png",
    width = 6, height = 6, units = "in", res = 300)

# STEP 3: Print the plot
polar

# STEP 4: Turn off the graphics device
dev.off()
```

You can read about R's plotting devices by reading the "help" page for the `png()` function - type `?png` into your console to bring it up.

The [openairmaps]{.pkg} package can create interactive HTML maps. To save these, you need to use the `htmlwidgets::saveWidget()` function. This is simpler than saving a static plot as you will not have to worry about resolution or dimensions. 

```{r}
#| label: demo-savewidget
#| eval: false
library(openairmaps)

polarmap <- polarMap(polar_data, "nox")

htmlwidgets::saveWidget(widget = polarmap, file = "polarmap_london_nox.html")
```

Another way of sharing analysis produced using [openair]{.pkg} is in [Quarto](https://quarto.org/) (or [Rmarkdown](https://rmarkdown.rstudio.com/)) reports. These well documented on their respective websites.
